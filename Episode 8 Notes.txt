Agenda of Episode : We'll study about class based components here.

1. Class Based components.
=> Classes based components is a older way to create components. Functional way of components is a newer way. These days,
   class based components are not required.

=> Class based components are very important to know. Reasons : 
   (1) It's asked a lot in interviews since a lot of companies are still using older react. And they want you to know it.
   (2) If you know class based components, then understanding of react will be very strong since if you know earlier ways,
       the newer way fundamentals will become even stronger.
   (3) It'll teach you things on a deeper level, how react component renders and react lifecycle works.

=> We first write a functional component called "User.js" which has detail about the author like name, location and contact.
   We then render this component inside About component.

=> Now we'll change this this User.js component(which is functional component now) to a class based component. A new correspoding
   class based component of "User.js" is created as "UserClass.js". It's class based component.

=> Like functional component at the end is a JS function, class based component at the end
   are normal Javascript classes. To tell this class represent a component, our class
   should extend from the class React.component. 
    
   Example : 
   class UserClass extends React.Component {
     
    }

=>  Now this class will have method called render() { } which will return
    a piece of JSX. Thus functional component are JS functions return a piece of
    JSX. And class based components are the JS classes which extends React.Component and
    have a render method which returns a piece of JSX.

=>  Example : 
    class UserClass extends React.Component {
      render() {
         return (
            <div className="user-card">
            <h2>Name : Ayush</h2>
            <h3>Location : Los Angeles</h3>
            <h4>Contact : ayushb@usc.edu</h4>
            </div>
         );
      }
    }

=> What is React.Component ? It's a class given to use by React, which we use
   to inherit some peroperties and methods in our class.
   So we need to import React which as the Component class in it ie. React.component
   
   import React from "react";

=> We render these class based components in the same way we do functional components. 
   Example : <UserClass/>

2. How to pass and access props in class based components ? 
  
   - Passing the props is same as we do in functional components : 
     <UserClass name="Ayush (from Class)" />
   
   - Accessing props : 
     we read these props inside the constructor of the class and then we need to pass 
     these props to the super() class like super(props). Now the props are ready to use
     in JSX using this.props;
 
     class UserClass extends React.Component {
      constructor(props) {
         super(props);
      }
      render() {
         return (
            <div className="user-card">
            <h2>Name : {this.props.name}</h2>
            <h3>Location : Los Angeles</h3>
            <h4>Contact : ayushb@usc.edu</h4>
            </div>
         );
      }
      }
      export default UserClass;

=> Why we write super(props) ?   Important. Refer this as well - https://www.turing.com/kb/beginners-guide-to-super-and-super-props-in-react
       
       /React.Component under the hood   ................................ (1)
         const instance = new DefinedComponent(props);
         instance.props = props;
      
      => because it makes the props available in the render method(); using this.props
       
      Note  : 
      We can also do like this in constructor : 

      constructor(props) {
         super();
         this.props; 
      }

      We can do this as well and it'll still work but using super(props) is the recommended and more 
      standard way to handle constructor initialization in React class components. It's clearer and directly
      aligns with how React components are designed to handle props. We usually follow this since,
      any data recieved in child in inheritence is first passed to parent, in order to avoid any inconsistencies. 
      and when we pass props to parent ie. React.Component, it internaly assigns props to our child class ( see above .....(1))
      so that we can use this.props in our code. 
       
      Note : When we inherit a class a child class. In the child class constructor, we always
      have to call the super() first before doing anything, else JS engine throws an error. 
      It does that to protect us since, parent component classes show be initialized first before accessing
      child class. 

=> This, in class based components, always create a constructor and 1st line should be super() and pass props in super() if needed. very Important.
   Remember this. 
   constructor(){
      super()
   }

=>  To make code clean, we can destructure the props object for extract name and location from this.props;

    const { name, location } = this.props;
    return (
      <div className="user-card">
        <h2>Name : {name}</h2>
        <h3>Location : {location}</h3>
        <h4>Contact : ayushb@usc.edu</h4>
      </div>

   - now we don't have to call this.props everytime, we can just use name and location.

3. Creating states variables in class based components.

  => In functioanl components, we use a useState hook to create a state variables. 

  =>  These hooks (eg. useState) are new way to create states variables (were released in 2019). Earlier we did not have these hooks. 
      We have more traditional ways to create state variables.

  => Why props and states variables are created in constructor() of class based components ? 

      - Traditionally, state variable were created when instance of a class is created. When we say, we are loading class based components on the
      web page, it means we are creating an instance of the class and giving it some props. And whenever, you create an instance of the class, 
      the constructor of the class is called. 

      - Thus constructors are best place to recieve the props and create the state variables. So earlier, when hooks were introduced. We used to create
      state variables using this.state = {}. "state" is a reserved keyword.  It's simple an JS object with set of state variable names and initial value assigned to them.

      example : 
      constructor(props) {
         super(props);
         this.state = {
            count: 5,
         };
      }
   
     - To use these state variables in our JSX in render() function

       <h2>Count : {this.state.count}</h2>

     - To make it look neat, we'll destructure this state object to extract count and use more cleanly.

        render() {
         const { name, location } = this.props;
         const { count } = this.state;
         return (
            <div className="user-card">
            <h2>Name : {name}</h2>
            <h2>Count : {count}</h2>
         ....
         ....
         );
         }

=> Creating multiple state variables in class based components. 

   - "this.state" is a big object which will have all the state variables of our component. 
   - Example : 
     constructor(props) {
         super(props);
         this.state = {
            count: 5,
            count2: 2,
         };
      }
   - Using this 2nd count2 state variable : 
      render() {
         const { name, location } = this.props;   // destructuring object
         const { count, count2 } = this.state;   // destructuring object
         return (
            <div className="user-card">
            <h2>Name : {name}</h2>
            <h2>Count : {count}</h2>
            <h2>Count2 : {count2}</h2>
            ....
         )
        }
   
=> Updating state variables in class based components :
  
   - In functional components, we had set() function to update the state variables. We don't have that in class based components. 
   - We have update state variables now - count and count2.
   - Lets build a functionality where, if I press a button my count state variables will update and will get updated on our UI.
   - Many will think to this way, but This will NOT WORK :  

      <button                      // WRONG WAY
          onClick={() => {
            this.count = this.count + 1;
          }}
        >
   Important : We'll never update out state variables directly using "=" in class based components.
   
   - To do this, React gives access to an important function "this.setState()".

   - this.setState() function can be used anywhere inside our class.

   - How to use this.setState() function ? We'll pass an object to this.setState() which will have updated values of our state variables.
   
   - For example, to increase our state variable "count" by 1, we'll do : 
     <button
          onClick={() => {
            this.setState({
              count: this.state.count + 1,    // we are not using "=" here to update the state variable.
            });
          }}
        >
   - As our state variable changes, React will re-render our components and will just change the count value. 

   - Suppose we want to update both states together we can club them together as well( Generally we won't get such case) : 

     <button
          onClick={() => {
            this.setState({
              count: this.state.count + 1,    // we are not using "=" here to update the state variable.
              count2 : this.state.count2 +1
            });
          }}
        >  

=> How this re-rendering works behind the scenes in class based components ? (We'll learn this in detail going ahead in episode..)

   when we change the states using this.setState() passing an object of state variables to change, our whole component will re-render and It'll 
   compare this state object with the global state object defined in the constructor. It'll use reconciliation algorithm to find a diff of the 
   state variables which are changed and React will only change those state variables and render them in the actual DOM and keep other item of actual DOM same.

4. Lifecycle of React class base components ********** (Very Very Important for Interviews) **********

=> We'll see how this class based component is mounted/loaded on the web page.

=>  whenever a parent component is rendered/mounted on webpage, it first starts rendering the JSX of the component. When it encounters another child component inside it 
    being called using <componentName/>, it then start rendering that child component's JSX. 

=> When it finds a class based component as child component. Example when we are rendering About.js component, it finds <UserClass/> which is a 
   class based component. It then starts loading that class based component. A new instance of that class is created. And when this class is 
   instantiated, first things what happens is that it's constructor is called. Once the constructor is called. After that render() is called. 

=> Flow is : 
   Rendering a class based component -> instant of the class is created -> constructor() is called -> render() is called
   
   - you can verify this by putting console.log in constructor and render(). The log of constructor will be printed first. 

=> This becomes little complicated when the parent is also a class based component and the child is a class based component too. 

=> For this lets make out parent component About as class based component which is calling child UserClass( a class based component).

=>  The flow of rendering when both parent and child are class based components is like this : (can be verified with logs)

    1. Parent constructor()
    2. Parent render()
    3. Child constructor()
    4. Child render()

=> This is how lifecycle of React and class based components work.Easy right ? Lets see further XD

5. componentDidMount() method of class based component. 

  => But this was easy, and Akshay said, lifecycle of components is a very imporant interview question. Lets see another example of something 
     ticky XD to get better idea.

  => For implementing class based components, along with constructor() and render() React also provides us a very important function. 
   - componentDidMount() {}

  => When a class based component is loaded, first the constructor() is called, then render() is called and when this class based component is mounted
     on the DOM, componentDidMount() is called.

     Flow of calling these when a component is loaded : (Again can be verified by putting logs)
     (1) constructor()
     (2) render()
     (3) componentDidMount()

     This is the lifecycle of the React component.

=> But But But, whats the flow then we have parent class component with componentDidMount() a child class component. Eg. ABout (parent) and useClass(child)
   Flow will be : 
   (1) Parent constructor()
   (2) Parent render()
   (3) Child constructor()
   (4) Child Render()
   (5) Child componentDidMount()         // observe child componentDidMount() is called before parent's componentDidMount()
   (6)  Parent componentDidMount()

=> How this happened that child componentDidMount() is called before parent's componentDidMount() ? *** Important Interview Question ***
   This happens because, when the parent is mountering it's JSX line by line, it sees there's a child class component, it goes to this child component,
   calls it constructor() first then it's render() function. Once that is done, child's componentDidMount() is called since it finished it's mounting.
   Now control comes back to the parent which as not yet finished it's mounting since mounting of child had to finished first. Now parent component's mounting
   is continued and after it's done, parent componentDidMount() is executed.

=> In short -> children's class compontent mounting happens before parent's mounting since child is within parent. Only if child finish, can the parent
   finish mounting.

=> Use of componentDidMount() ? Why React has given us this method ? - Make API calls :)

   - There are certain things we do after the component is mounted successfully (OR) render successfully. 
   - It's similar to useEffects() in functional components. It is used to make API calls. 
   ** IMPORTANT**** 
   - Why API calls are done in componentDidMount() ie. after component is rendered?  Just like useEffects(). We do this since if we do it before 
     rending the component, the API call will be made first and no initial UI will render for user. It'll be a blank screen till we get the data 
     from API. This is not a good user experience. Thus we load some initial UI. (Shimmer UI mostly), then after initial render, we make API calls
     in componentDidMount() and update your UI again with re-rendering.

=> (It'll confuse you, see carefully for interviews ) 
   Lets see how component lifecycle works when we have multiple child class based components inside a parent class based component. 
  
   Example :
     <About/>              // Parent class Component
       <UserClass/>        // Child 1 class Component
       <UserClass/>       // Child 2 class Component
      </About>            

   Note : When we are calling the same component twice (like above for UserClass), we are creating 2 different instance of the same class.
   Example, we'll use same component class but we'll pass different props. 

   Wrong flow : (This is what most people expect )
    
   (1) Parent constructor()
   (2) Parent render()
   (3) Child1 constructor()
   (4) Child1 Render()
   (5) Child1 componentDidMount()
   (6) Child2 constructor()
   (7) Child2 Render()
   (8) Child2 componentDidMount()
   (9) Parent componentDidMount().       
   // This is wrong flow. 

   Correct flow : 

   (1) Parent constructor() 
   (2) Parent render()
   (3) Child1 constructor()
   (4) Child1 Render()
   (5) Child2 constructor()
   (6) Child2 Render()
   (7) Child1 componentDidMount()
   (8) Child2 componentDidMount()
   (9) Parent componentDidMount()   // observe all the mounting is getting done at end. (Explained below..)

=>  *** (Important) ****
   Reason for this :  

- To understand this we'll deep dive little and understand react lifecycle diagram.
- Diagram : https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
- If you understand this diagram, nobody can defeat you in lifecyle process of react rendering :)
- Explanation starts at timeline of 1:20:20 in Episode 07.
- React is fast because it has two phases : Render phase and Commit phase.
- In Render phase : When a componenet is rendering, first the constructor() is called and then the render() method is called.
- In Commit phase : Comes after Render phase, React actually updates the DOM here and after that componentDidMount() is called.
- Now, when React see there are two children inside a parent, to optimize the rendering, react will batch the Render phase of these two children.
  and only after both their render phase is done, it'll perform the commit phase(By updating to DOM and calling componentDidMount() ). 
  Commit phase of children will also be batched and will happen after batched render phase of children.
- This is an optimization of React.
- Thats why, our flow looks like above (correct one).   
 
   (1) Parent constructor() 
   (2) Parent render()

   Batched render phase of children : 
   (3) Child1 constructor()
   (4) Child1 Render()
   (5) Child2 constructor()
   (6) Child2 Render()

   Batched commit phase of children : 

   // Actual DOM updates here for child 1 and child 2
   (7) Child1 componentDidMount()
   (8) Child2 componentDidMount()

   // Actual DOM updates here for parent
   (9) Parent componentDidMount()   

=> ****IMPORTANT**** Why this optimization is done by batching Render phase and Commit phase : 

  - When the react is in Render phase it triggers the reconciliation process via setState(), then diff is calculated using old Virtual DOM
  and new Virtual DOM. After it finds the diff, it updates the DOM in commit phase.
  
  - Now rendering phase with reconciliation process and finding the diff is very very fast. But updating the DOM takes time. Thats why it just batches 
    the rendering phase of the children since they are fast can be quicky implement. And after all the rendering process of childrens, DOM is then
    udpated. Manipulating the DOM is an expensive task. Thus, it batches the "Render" phase and then after that it manipulates the DOM with "C ommit" phase. 

=> Making API calls in componentDidMount()
  - Make the code clean : Now lets remove the 2nd <UserClass/> in <About/> and keep only 1 <UserClass/> to keep things simple. Lets also remove count from state variable.

  - We'll make componentDidMount() function as async to use await inside that and we'll create state variable of name and location to re-render
    the UI once we get the data from API.
    
   import React from "react";

   class UserClass extends React.Component {
   constructor(props) {
      super(props);
      // console.log("userClass constructor - Child " + this.props.name);
      this.state = {              // state variables defined
         name: "",
         location: "",
      };
   }
   async componentDidMount() {        // componentDidMount function made async
      const data = await fetch("https://api.github.com/users/ayushbhardwaj10");
      const json = await data.json();
      console.log(json);         
      this.setState({                // updating state variables to re-render the UI
         name: json.name,
         location: json.location,
      });
   }

   render() {
      console.log("userClass render - Child " + this.props.name);
      const { name, location } = this.state;     // destructuring the state object. 
      return (
         <div className="user-card">
         <h2>Name : {name}</h2>
         <h3>Location : {location}</h3>
         <h4>Contact : ayushb@usc.edu</h4>
         </div>
      );
   }
   }
   export default UserClass;

=> "Mounting" cycle and "Updating" cycle of React Cycle. Refer same Diagram : https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

    (1) Mounting Cycle :
         Initially component will render with the default values of state variables. It starts with "Render Phase".It calls the constructor() then 
         it calls the render() function. Now, "Commit Phase" begings and the component is mounted on the actual DOM. Now the componentDidMount() will called
         and when we receve new data from API, we use this.setState() to udpate out state variables. Now our "Updating cycle" will begin.
   
    (2) Update Cycle :  A new function componentDidUpdate() is introduced here. :)
         In again in out updated cycle, we again call the render() function with the updated state variables. Note: constructor() is not called again. You
         can check from the diagram as well. And again the new component is mounted on the actual DOM and it'll then call "componentDidUpdate()" (It's
         different from componentDidMount())

         - componentDidUpdate() is also a function like componentDidMount(). It's called after the "Updating cycle".

         So the flow is : 
          
         ---- Mounting Life cycle -----
         (1) constructor()  
         (2) render()  (dummy data used)
         (3) HTML renders on Actual DOM and we see on web page for few milli seconds.
         (4) componentDidMount() - API call 
         (5) this.state() to update the state variable

        ---- Updating Life cycle -----
        (1) render() (API data used)
        (2) HTML renders on Actual DOM and we see on web page.
        (3) componentDidUpdate()
  
6. Unmounting cycle (Check from same diagram ) https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
     
    => componentWillUnmount() {} - this function is called just before our component is unmounting. 

    =>  What is "unmounting" ? unmounting means when out componenet will be removed from the UI.
    => it'll happen we go to a different component. Eg. if we put componentWillUnmount() in About.js and move to a different component. Example
       in Home or Contact us. It'll be called.


7. Conclusion : Class based components were confusing with these many Lifecycle phases and functions like componentDidMount(), coomponentDidUpdate()
   and componentWillUnmount(). But now in functional components, it has simplified a lot. We write less code to do more. Thats why it's gaining
   more popularity now.

   Total Episode Ends at 2:00:00. Akshay Saini words : This much information is enough for class based components for interview since nobody 
   uses it these days.In, Later part of episode after 2:00:00, Akshay Saini talks about it in more details from earlier Live Batch.


       

   



   










   
   
     


    


