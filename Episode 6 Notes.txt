Agenda of this Episode : How our React Application will communicate with outside world, ie. how our React app will make a backend API call 
and fetch the data. 

///////////////////////////////////

1. Monolith VS Microservice Architecture 

2. Monolith Architecture 
   
   => A same project where we'll have code for API, UI, Authorization, Database etc. 
   => Disadvantages : 
      (a) Multiple deployments

3. Microservice Architecture :

   => Difference service for different project.
   => Difference services for UI, Authorization, Database, etc.
   => Based on "Seperation of concerns".
   => It follows single responsibility principle where each microservice has it's own independent responsibility.
   => How do these microservices interact with each other ? Using different connections such as RestFul connections.
   => Our React Project is a UI microservice.
   => We can have multiple languages for different microservices.
   => All these services run on their own ports. Example UI on port 1234, Backend to port 1000. All these microservices can have
      same domains.

4. Two ways to call API to Fetch data : 
    
   (1) As soon as our page loads, make an API call, wait for data to come and render data to UI.
   (2) As soon as our page loads, we'll render the UI and then call the API as new Data from API comes, we'll re-render our UI

   In React, we use the second approach mostly. Reasons : 
   (a) It gives a better UX since page is frozen till we get API data and UI suddenly appears.
   (b) 2nd approach it better because , atleast we show some skeleton to the user and quickly update the UI when data comes.
   (c) We don't have to worry that we are rendering two times, since react rendering is very efficient due to React Fiber as learn above :)

5. useEffect Hook 
   => It's a simple utility function provided by React just like useState.
   => importing useEffect, named import is used : import { useState, useEffect } from "react";
   => It requires 2 arguments : 
      (1) A callback function
      (2) An array of dependencies
      Example : useEffect(()={
         console.log("useEffect called");
      }, [])
   => When will this useEffect callback function be called ? It'll be called immediately after your component renders.
   => Purpose of useEffect : To do anything after component is rendered. 
   
   =>  Which one will print first "UseEffects is called" or "Body rendered" ? 
        useEffect(() => {
            console.log("useEffect is called");
         }, []);

       console.log("Body Rendered..");

       Ans : Body Rendered..
       Explanation : UseEffect() callback function is called after the rendering of component.

   => Sequence of component rendering : Component function start executing line by line everything from top to bottom before the returning JSX. When it
      encounters useEffect, it stores it's callback function to be involked after component is rendered. It then go to return JSX and renders
      that JSX to DOM.
   =>  Rendering of component includes : 
       all the javascript statements before JSX return and the JSX rendering to DOM. Only after this useEffect() callback is called.

   => useEffect will be used to call the API after rendering component.

   => we use fetch() API. It's a webAPI given by browsers : 
        useEffect(() => {
         fetchData();
      }, []);

      let fetchData = async () => {
         let data = await fetch("https://www.swiggy.com/dapi/restaurants/list/v5?lat=12.9351929&lng=77.6244806999999&page_type=DESKTOP_WEB_LISTING");
         let jsonData = await data.json();
         console.log(jsonData);
      };

   => Now we render our app with this new jsonData we got from API. How to do it ? 
      We update the data which is a state variable using set function given in useState() hook.

        let fetchData = async () => {
         let data = await fetch("https://www.swiggy.com/dapi/restaurants/list/v5?lat=12.9351929&lng=77.62448069999999&page_type=DESKTOP_WEB_LISTING");
         let jsonData = await data.json();
         setListOfRestaurants(jsonData?.data?.cards[5]?.card?.card?.gridElements?.infoWithStyle?.restaurants || []);
      };

      Note : We always use optiona chaining with "?". If any of the intermediate value is null, it'll throw runtime error, but if we use
      optional chaning with "?" and any intermediate value is null, the value will be undefined. It'll not display anything on DOM in this case rather
      than causing runtime error.

  => Conditional Rendering : Render the component, only after the data from fetch is available => We do this since, it can show errors when we try read
     values from the expected object before data is fetched. We can show some spinning loader

      {listOfRestaurants.length > 0 ? ( // conditional rendering, intially out listofRestaurants data is empty
          listOfRestaurants.map((restaurant) => <RestaurantCard key={restaurant?.info?.id} resData={restaurant} />) // passing Key is very important for optimization. Explained in notes :)
        ) : (
          <h2>Loading...</h2>
      )}
   => Is showing Spinner a good way ? No it's not.  

6. Shimmer UI : Overcome above problem of what to do when data hasn't returned from API to render on UI. 

   => Instead of showing loader/spinner. We show a dummy/skeleton of the page till our UI loads.

   => Why it's better than showing Loading spinner. Loading spinner doesn't give a better user experience. With Shimmer UI, we can quickly give am immediately 
      to user, whats going to render in future and it's more intutive :)

   => So we add the Shimmer UI intially when we are doing rendering for the first time. We then call the API to fetch data. Once we have our data, 
   we render the actual UI. 

  => Lets create a new component Shimmer.js

7. Why we need listOfRestaurants as state variable here. Couldn't have we done same thing using normal Javascript variable. 
   
   => To revise this, we'll one more feature here : Login, logout. We'll not do actual authentication but will change login to logout and logout To 
      login.
   
   => If we use a normal javascript variable, and if we update the variable, it'll get updated. But it'll not render the UI with updated change.
      Making the variable as state variable using useState() hook does this for us. It then becomes a special variable, with a lot of power.

8. How it re-renders behind the scene. 
******** Very Important :  React will render the entire component again but it'll only update the actual DOM with the diff it calculates. 
       
   => The parts of component which have not changed, will remain intact in the actual DOM. So the full of the component is executed again but actual DOM is updated 
      just with diff and other parts remain intact. You can prove this by putting a console.log("header rendered.."); before return JSX.This console.log 
      statement would be printed everytime, when our state changes, this implies whole component's code is executed again. But the other parts of the
      component which have not changed example an image being fetched from server to put to DOM, will not be fetched again. It'll remain intact 
      in actual DOM. It'll check the old virtual DOM and new Virtual DOM and find the diff and see only the button is getting updated and no change in any other place.


9. Adding Search Functionality with a input type of text with a search button.
 
   => To track the value of the input type of text, I need to bind this input box to a local "state" variable of react.
   
   =>  const [searchText, setSearchText] = useState("");     ( ERROR !!!!!!!!!! )
       <div className="search">
          <input type="text" className="search-box" value={searchText} />
          <button
            onClick={() => {
              // Filter the restaurant and update the UI
              // get the searchText
              console.log(searchText);
            }}
          >
            Search
          </button>
      
       Note : If we do this, we'll not be able to type anything in the input text and console will also throw an error : index.js:1 Warning: You provided
        a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use 
       `defaultValue`. Otherwise, set either `onChange` or `readOnly`.

   => Reason for error : "searchText" value is bind to the input box. So if these are binded and we are trying to change input box value, our "searchText"
      variable value is not getting changed. Since these are binded, it's not possible to change one of them and not other one. 
      Solution : Since, both are binded together. Change both the values together. change the "searchText" variable as input box value changes 
      using onChange() dom event.
   
   => Correct way : 
    
      <div className="search">
          <input
            type="text"
            className="search-box"
            value={searchText}
            onChange={(e) => {
              setSearchText(e.target.value);
            }}
          />
      <button
      onClick={() => {
         // Filter the restaurant and update the UI
         // get the searchText
         console.log(searchText);
      }}
      >
      Search
      </button>

   => Now whenever, our local state variable "searchText" changes as we type in input text, * our full component re-renders *. console.log() before return JSX 
      and you can verify :). 
   
   => But, it's soo damm effient, that it only updates the diff to the actual DOM. ( reconciliation algorithm ). You can render as many times as you want,
      it'll still be efficient. Thats the power of "reconciliation algorithm" and since it does very efficient DOM manipulations.
   
   => Thus, in every re-render, react only updates the input text box in actual DOM.

   => In search functionality, as we put a search text, we filter the listOfRestaurants which incudes our search text and then update this local state
      variable. When we do this, react re-renders the entire component uses reconciliation algorithm to calculate diff and update only that to actual
      DOM.

   => There's a bug, we are filtering the restaurants, then we are updating the original list of restaurants. So if we filter 2nd time, it'll search
      from the 1st time filtered list but not from original list. It should logically filtered from original list of restaurants we fetched from API.

   => Thus we create 1 more state variable : filteredRestaurant, where we keep filtered restaurants and listOfRestaurants has the original list of
      restaurants fetched from API and remains intact always.
      const [listOfRestaurants, setListOfRestaurants] = useState([]);
      const [filteredRestaurant, setFilteredRestaurant] = useState([]);
   

   
  
  

      







  
   