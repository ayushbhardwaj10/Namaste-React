Agenda : We'll learn everything about routing and dive deeper into userState and useEffects hooks
////////////////

1. Diving deep into 'useEffect' hook.
 
 => How useEffect is called in javascript ? Using two arguments : 
    (1) A callback function. 
    (2) A dependency array.  

   Only passing the callback function is mandatory. Dependency array is optional, we can even not pass anything as second paramater. 
   example : useEffect(()=>{
      console.log("useEffect called")
      });
   
=> The 2nd argument of useEffect() hook (ie. dependecy array) changes the behaviour of render of useEffect(). Example : 3 CASES below.

=> Case 1 : If we do not pass dependecy array to useEffect :  useEffect is called after EVERY render of the component.
   example : useEffect(()=>{
      console.log("useEffect called")
      });

=> Case 2 : If we pass empty dependecy array to useEffect ie. [] : useEffect is called on initial render only (just once)
   example : useEffect(()=>{
   console.log("useEffect called")
   },[]);
   
=> Bydefault, useEffect() is called after every component render. But if we pass a empty dependency array, it'll be called just once. 

=> Case 3 : If we put something in dependecy array  : It'll only be called when the dependency changes.
   - What can you have in dependency array  ? If I put a state variable in dependecy array, then everytime this variable changes,
     my useEffect() is called.
   
   - Example : 
   useEffect(() => {
     console.log("useEffect of header rendered");
   }, [btnName]);

   - It'll always be called after initial render and then everytime our dependency variables change. 

2. Tips to use useState() hook.

=> Never use useState outside of your component function. A error will come on console. Error comes since it's used to create local state
   variable inside functional components. 

=> Call useState() on the top of functional components. It's a good practice. 

=> It's not a good practice to call useState() inside any if statement or any function inside your functional components.
   Ex : if(){
       const [searchText, setSearchText] = useState("");      // never do this to avoid inconsistencies.
   }
   Thus, state variables are meant to be created at the higher level of your functional component and nowhere else. It'll avoid unnecessary
   errors which useState can cause.

3. Creating basic Routing in React 

=> We'll use a npm library to do this : "react-router-dom". We'll use newely launched version 6 of this. Previous popular one was version 5.

Steps for add routing in React : 

   (1) Install it : npm i react-router-dom
       Whenever, we have to use Routes, we need to create Routing configuration. We'll do in App.js file.

   (2) In App.js, for creating the routing configuration, we'll import using : 
   
   (3) import { createBrowserRouter } from "react-router-dom";

   (4) Routing configuration talks about what will happen on a particular route. Ex: what will happen if I go to /about or /home.
       
      const appRouter = createBrowserRouter([
      {
         path: "/",
         element: <AppLayout />, // means App.js component. It's function name is "AppLayout". Look above.
      },
      {
         path: "/about",
         element: <About />,
      },
      ]);

    (5) Just defining the configuration, will not add routing to our app, we need to provide this configuration to our app to render it.

        - We'll use "RouterProvider" component which is imported from "react-router-dom" only.

        - It's a prewritten component writter by "react-router-dom" library developers. 
       
        - We'll render react components in App.js using this code : 

         const root = ReactDOM.createRoot(document.getElementById("root"));
         root.render(<RouterProvider router={appRouter} />);
        
       - We pass RouterProvide component (pre-designed for by react-router-dom library developers) and pass our configuration to it in 
         "router" prop of this component. 

       - Before using routers, we're using below code : (which we'll replace with above code)
         const root = ReactDOM.createRoot(document.getElementById("root"));
         root.render(<AppLayout />);
      
      (6) Thats how we create and add react routers to our app.

4. Recommended to use "createBrowserRouter" : 
   There are various kinds of course in React Router documentation like : createHashRouter, createMemoryRouter, CreateStaticRouter etc.
   but React router libray docs recommends to use "createBrowserRouter" only for simple use cases. Other routers are for differnet
   use cases. We'll be using "createBrowserRouter" only.

5. Shortcut in vscode to automatically case a basic component function for you instead of you typing everything. 

   shortcut is : rafce

   Suggestion : Do not do this. It's a good habbit. The more you write, the better it'll be for you to learn. You can use this when you are
   working on IT company projects.

6. What if I type some random endpoint URL ? example /xyzzz.

   => It throws and unexpected Application error with a default 404 error page.  This error is handled by react-router-dom.
   => It's recommended to handle this in a better way by showing our own error page. 
   => Make your own Error handling component , we created Error.js here. 
      Add this as "errorElement: <Error />" in the obeject where you defined path :"/"
     const appRouter = createBrowserRouter([
      {
         path: "/",
         element: <AppLayout />, // means App.js component. It's function name is "AppLayout". Look above.
         errorElement: <Error />,
      },
      {
         path: "/about",
         element: <About />,
      },
      {
         path: "/contact",
         element: <Contact />,
      },
      ]);

7. To handle this error more efficiently, React-router-dom library also provides us a Hook.

   => import {useRouteError} from "react-router-dom";
      
   => How do we know if "useRouteError" is a hook. It starts with "use". It's a common industry standard. This hooks provides us
      more detail about what kind of error occured.
   
   => if we use it and console.log it : 

      const err = useRouteError();
      console.log(err);

      we can show this error by : <h3> {err.status} : {err.statusText}  </h3>
      
      It'll print an object describing what went wrong.  
   
   => This library is super powerful. It's a very mature library and they keep updating it. Version 5 was complicated so they launched
      a easier version 6. 

8. Children routes 

  => use case : Suppose I want to keep the header intact and below contents should change.
     Eg : currently in my <About/> component, there's no header component
      
  => It should be like this : 
     (a) When on "/" : 
         <Header/>
         <Body/>
      (b) When on "/about" :
          <Header/>
          <About/>
      (c) WHen on "/Contact" :
          <Header/>
          <COntact>

  => We do this using "children" key : 

      const appRouter = createBrowserRouter([
      {
         path: "/",
         element: <AppLayout />, // means App.js component. It's function name is "AppLayout". Look above.
         children: [
            {
            path: "/",
            element: <Body />,
            },
            {
            path: "/about",
            element: <About />,
            },
            {
            path: "/contact",
            element: <Contact />,
            },
         ],
         errorElement: <Error />,
      },
      ]);

   => How do we know at which position we need to render children components in out parent app ? 
      Using <Outlet/> provided by react router library. 
      (1) Import it : import { createBrowserRouter, RouterProvider, Outlet } from "react-router-dom";
      (2) Define where to render it : 

         const AppLayout = () => {
         return (
            <div className="app">
               <Header />
               <Outlet />
            </div>
         );
         };
        It'll render below <Header/> component always
   
   => <Outlet/> will be replaced by our components according to pur path

8. We'll add clickable navigations for routing. Eg: Clicking on "about" on UI should render the <About/> child. 

   => Wrong way : Use anchor tags with href Example : <a href="/about"></a>

   => We never use anchor tags to route to a different page. Reason : If I use a anchor tag to route to a different page,
      the while page gets refreshed/reloaded. We do not want to refresh the whole page but still navigate it. Thats the magic
      React does for us. :)
  
   =>  use "Link". It's a superpower given to us by "react-router-dom" for routing without reloading/refreshing the page.
       
      - import it : import {Link} from "react-router-dom"
      - To use : It's similar to <a> anchor tags. Instead of <a> use <Link> and instead of "href" , use "to" to tell which route to go.
        Eg : <Link to="/about">About us</Link>
   
   => Thus our page is not reloading now, but just the components are getting refreshed. Thats why, react applications are known as
      "Single Page applications (SPA's)". It's just one single page which reloads, and then router takes the control and only the components
      within out single page changes according to the path. 
   
   => Traditional web apps, for every route change, our page will reload again. It doesn't give a smooth experience to the user.
   
9. Why React applications are called as "Single Page applications (SPA's)" ? 

   => Explained above. 

10. Two types of routing(Not "Redering") we can have in our web applications : 
    
    (1) Client side Routing. (Not "Rendering", thats completely different)
    (2) Server side Routing.

    - Client side routing : No network calls here. All the components are already there on client side. So as path changes, the component changes
      immediately without network calls.
    - Server side routing : as we go to a route example /about, browser makes a network call to server, fetches the web page against /about
      and then renders it. This refreshes/reloads the page.
   
11. Dynamic Routing. 

    => Use case : If I click on a restaurant card, I should be taken to it's page with that restaurant's information. Our routes will be Dynamic
       here depending on which restaurant we clicked. 
      
    => React router dom confiugration : 
       {
        path: "/restaurants/:resID",
        element: <RestaurantMenu />,
       }

      anything after : is dynamic. resID is dynamic here and will be depedent on which resuratant I click.

   => Now our restaurantMenu component data should change dynamically as per our routing url.

   => Lets get the data dynamically in this component from swiggy API in RestaurantMenu component. We'll use useEffects for this. 
      See the useEffects code. 

   => We'll load conditional rendering to load shimmerUI if our resInfo data is null. See the code for this. 
      This code is industry followed practice.

   => Now, to make the page dynamic, we need to pass some data(restaurantID here) to RestaurantMenu component and read in RestaurantMenu component.

   => How should I read this dynamic resID ( "/restaurants/:resID" ) : 
      React router dom library provides a hook for it - "useParams"

      import { useParams } from "react-router-dom";
      const { resID } = useParams();

      u seParams returns an object with key resID and value as the value we passed. Thus, we destructure on the fly with {resID} = useParams();

   => Now lets pass the resID from restaurants cards to restaurantMenu when we click on restaurants card. we'll add Link to change the route to restaurantMenu page.

      in Body.js : 
      import { Link } from "react-router-dom";

      filteredRestaurant.map((restaurant) => (
         <Link key={restaurant?.info?.id} to={"/restaurants/" + restaurant?.info?.id}>
            <RestaurantCard resData={restaurant} />
         </Link>
         )) // passing Key is very important for optimization. Explained in notes :)
      )

      We'll use <Link> and put the <RestaurantCard/> component within it. In Link, we need to pass to with dynamic restaurant id and 
      key parameter. 

      Note : whenever we use map to render components iteratively, we need to use "key" to uniquely identify each component uniquely. 
      We need to use "key" on the parent element inside map. Thus we are using on <Link> here.
   
   => Note, as we change the routes, none of our pages are reloading :). It's a single page application (SPA)

12. Few more detail about Link :
   => If we check in developer tool, <Link> tags are converted to <a> tags with href. How is it helpful for us ? 
      But we had put <Link> with "to". 

    => Link is a component which is given to use by "react-router-dom" library but behind the scenes <Link> is using <a> anchor tags but 
       just doesn't reload the page unlike classic <a> anchor tags. <Link> is like wrapper over <a> anchor tags which changes the route also
       but doesn't reload/refresh the page.



   


     

  




   






    