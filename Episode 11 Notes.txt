Agenda of Episode :  Understanding the Data Layer of our React App and keeping it very efficient   : 
(1) Higher order components 
(2) Managing React Data - 
   (a) Lifting up of States, Controlled and UnControlled components
   (b) Props Drilling - React Context
////////////////

 1. Higher order component : Enhances and modifies a component

    => It's a simple javascript function which takes a component as input and returns a component.

   => Why do we use it ? When do we use it ? and what component does it take and what component it returns ?

   => Purpose : We need it because we take some component as input, it enhances the component, add some features to it and returns the component back.
   
   => Lets add this feature to our app. Some of the restaurants are promoted by Swiggy and we'll have a "Promoted" Label on our card card.
      So we'll write a higher order component (ie. A simple JS function), which will take a restaurant card code and return a restaurant card
      code having a promoted label on it. 

   => How will I know which restaurant will have promoted lable ? Lets find that from APIs  we get from Swiggy. For each restaurant, we have a 
      boolean feature "Promoted" which can be true or false. We'll use to print Promoted Logo on top of card.

2. Creating a Higher order Component : We'll create this higher order component below our RestaurantCard only.

=>   It's a normal javascript function which takes "RestaurantCard" comopnent as input and return a component, which is again a function. 
   Thus we are returning return () => {};. Now the component that we are return again returns a JSX. Thus we return :
        return (
         <div></div>
         )

   Final template for higher order function : 
      const withPromotedLabel = (RestaurantCard) => {
         return () => {
               return (
               <div></div>
               )
         };
      };

=> Complete Higher order component : 
   export const withPromotedLabel = (RestaurantCard) => {
      return (props) => {
         return (
            <div>
            <label className="absolute bg-black text-white m-2 p-2 rounded-lg">Promoted</label>
            <RestaurantCard resData={props.resData} />
            </div>
         );
       };
      };

  - We are passing props to our higher order component since we need to pass those same components to  <RestaurantCard/> component used inside 
    our higher order component. These props we'll send when we call this higher order function.
    
    
=> How to use these Higher order component. In Body.js, use this component as : 

    // importing our higher order component : withPromotedLabel
    import RestaurantCard, { withPromotedLabel } from "./RestaurantCard";
   
    // declaring a new component "RestaurantCardPromoted" using Higher order component "withPromotedLabel" since it returns a component.
    const RestaurantCardPromoted = withPromotedLabel(RestaurantCard);

     filteredRestaurant.map((restaurant) => (
            <Link key={restaurant?.info?.id} to={"/restaurants/" + restaurant?.info?.id}>
              {/* If the Restaurant is promoted, then add promoted label on it.*/}
              {restaurant?.info?.promoted ? <RestaurantCardPromoted resData={restaurant} /> : <RestaurantCard resData={restaurant} />}
            </Link>
       ))
    
    - We are checking from the API if there promoted feature is set to True then load
   
3. Managing React Data

=> All the React applications have two layer : 
   (1) UI layer - JSX 
   (2) Data Layer - State, Props, Local Variables, {} in JSX (javascript in JSX, data manipulating your UI)

   - UI Layer is powered by the Data Layer.
   - If we know how to manage data properly, we'll know how to make awesome React Apps. 
   - Senior Engineers are really good in the logic of their data Layer.

=> New feature we'll build to learn these things : If we go to swiggy and we click on a restaurant, it takes us to the restaurant page. 
   It has various sections (different for each restaurant) like "Recommended", Whop-A-Dosti Combo, Family Feast etc and each section has a 
   set of dishes. 

=> We'll extract the data from APIs corresponding to all the sections of data. The data coming from API is designated as "itemCategory". There's 
   a lot of other data too. We'll extract only item category data. 

=> We'll build a accordian for each section. Where when we click a header, it's content should open and close. The content for section "Recommended"
   for example will have a list of menu, which are recommended.
      
4. Lifting up of States, Controlled and UnControlled components -> Very Very Important.  (Can read on new Offical React docs as well)

=> It's used, when we have multiple child components of a parent component and changing the state from one of the child component show somehow
   change the states in other child components as well. Only way to do this is lifting the states up and instead of making the states for each child,
   make the state in parent and pass it to children so that we have controlled components. (controlled components are child components).
  
**** (Important) **** Now, all the accordian are independent component which are created using a map function and toggeling to open and close
   each of them currently doesn't toggle or affect any other accordian. 

=> A new Feature : If I open a according, it should collapse all the other accordians ? This is trickly, because now we are dealing with different
   components. Changing the state of one component should change the state of other components. This is tricky :)

=> Why it's hard : Each state variable is local to that component, how do we modify the local state variables of other components ?

.....................
=> React dev tools now : Please learn this in future in order to become a senior developer. Akshay Saini didn't teach this in detail.

   - We'll learn how to use React dev tools now : Start watching from 1:36:30
   - Components Tab : It gives an entire hirarchy of all the components in our app. And if we click on a component in it, on the right side 
     you can see the data layer of that component. We can see all the props passed to that component (ie. the data layer of this component).
     It's like a virtual DOM.
   - Profiler Tab : There are three things in this Profiler tab : 1. Flamegraph 2. Ranked 3. Timeline
   - Profile basically records your React Application. We can click on "start recording" button. Then whatever activity we do in our app, 
     everything will be recorded. Once we stop profiling. It'll show us all the acitvity we did and how much it took to render each component etc. 
     It'll be very helpful when we are building large scale applications to track which component is taking a lot of time to render and optimize it.
......................

=> To solve our above problem, since all the local states of all the components are independent of each other and we want if we open a accordian, it should
   collapse all other accordian. I want this "state to be lifted up". I don't want to give this power of show and collapse to Recommended component but
   give this power to it's parent ie. to Restaurant Menu.

=> We'll give a input to <RestaurantCategory/> component from <RestaurantMenu/> component whether to show the ItemList or not. Thus we are lifting the
   state up from all the RestaurantCategory component children to their parent, RestaurantMenu.

=> Thus we'll remove all the local states from <RestaurantCategory/> component and add the local state variable to it's parent component <RestaurantMenu/>.

5. Controlled vs Uncontrolled component : Simple Describes the child component w.r.t parent componet if child component can be controlled by 
   parent component fully or not. 

=> Uncontrolled component (takling about child component): When we had defined local state variable to open and collapse the accordian in our child component <RestaurantCategory/>, the parent 
   component <RestaurantMenu/> had no full Control over child component <RestaurantCategory/>. <RestaurantCategory/> was controlling itself using it's local state variable. 
   Thus our child component <RestaurantCategory/> is called uncontrolled component here. 

=> Controlled component (takling about child component): When we put the state variable to open and close the accordian in our parent component <RestaurantMenu/> and then pass it to 
   the child components <RestaurantCategory/> for it to open and close the according in it. The parent component has full control over it's child component. Then child component <RestaurantCategory/> 
   is called as a controlled component.


=> We'll pass a prop "showItems" as true from Parent component <RestaurantMenu/> to child <RestaurantCategory/> using :

   <RestaurantCategory key={category?.card?.card?.title} data={category?.card?.card} showItems={true} />

=> Suppose, I want to pass showItems = {true} only for first child and false to other children. To do this, we'll use the index of map function :

   {categories.map((category, index) => (
      <RestaurantCategory key={category?.card?.card?.title} data={category?.card?.card} showItems={index === 0 ? true : false} />
   ))}

=> updateing the state we passed from parent to child from child component. 

 - Now, I'm passing static props to child here. I need a feature that suppose I click on the accordian from the child. The state in the parent should
   get updated. How to update the state we passed from parent to child from child component ?
 - We'll create state variable in parent which will store the index of the child whose according would be open and accordian for all other
   components will be collapsed : 

   // declaring the state variable as described
   const [showIndex, setShowIndex] = useState(0);

   // if my index === showIndex, then send true to show accordian else send false. 
   {categories.map((category, index) => (
      // controlled component
      <RestaurantCategory key={category?.card?.card?.title} data={category?.card?.card} showItems={index === showIndex ? true : false} />
   ))}

- Now, if out child components can somehow change the showIndex state variable of parent using setShowIndex() function, we'll be able to achieve this task.
  : It's not possible directly, but we can do that indirectly. Lets see how.

- Lets pass setShowIndex() to the children.
  
   <RestaurantCategory
   key={category?.card?.card?.title}
   data={category?.card?.card}
   showItems={index === showIndex ? true : false}
   setShowIndex={() => setShowIndex(index)}    // we are passing a prop setShowIndex which is a function that will setShowIndex to given index using setShowIndex(index).

- calling this setShowIndex from child to change the showIndex. In child component <RestaurantCategory/>

  //Extracting setShowIndex() function using destructuring from props passed to child.
  const { data, showItems, setShowIndex } = props;

  // calling the function to update the showIndex variable with onClick
   onClick={() => {
      console.log("cicked header accordian");
      setShowIndex();
   }}

Note : If we set the index as null initially then none of the accordian will be open. 
ie. Changing  const [showIndex, setShowIndex] = useState(0); ->   const [showIndex, setShowIndex] = useState(null);

- Currently, there's a small bug in our app, if a according is already open, if we click on it again, it'll not close. It'll only close, if we
  open any other accordian. To fix this : 

   <RestaurantCategory
      key={category?.card?.card?.title}
      data={category?.card?.card}
      showItems={index === showIndex ? true : false}
      setShowIndex={() => (index == showIndex ? setShowIndex(null) : setShowIndex(index))}              
   />

   Explanation:  we use this setShowIndex function only inside click event of accordian header to collapse or open accordian body. When we click on the accordian header,
   and current index of child component === current set index (ie. child component accordian is already opened) then close it by setting showIndex to null.

6. Props Drilling   (Can read on new Offical React docs as well)

=> Our components in React, follow a Hirarchy (as we saw in React Dev tools "Components Tab"). It means sending props data from a parent to one of the
   decendant down the hirarchy will involve sending prop to each of the intermediate Components. This is known as "Props Drilling" as we are Drilling
   the props down the hirarchy. It's not necessary and not a good method when our app grows.

=> When your application grows and the hierarchy of your application increases. We know React as one way flow of data. We can only pass data ie. props
   from parent to children to their children and so on.

=> Suppose I have my data in a component and I want to send a data to one of it's decendant component. 
   Example our current hirarchy of component : RestaurantMenu -> RestaurantCategory -> ItemList
   and we want to pass some props from RestauratnMenu to ItemList, we cannot pass it directly to ItemList. First of all, I have to pass my props from 
   RestaurantMenu to RestaurantCategory component and then the data would be passed from RestaurantCategory to ItemList component. Once it's recieved
   int ItemList component, I can do whatever I want with this data.

=> Suppose I have 10 or more levels or nesting. I have to pass the data to soo many intermediate components and the intermediate components have no
   use of this data but they just pass to the next component in hierarchy. It's not a very good way to keep paasing the props from top bottom through
   each component. This concept is known as "Props Drilling".

=>  We can use prop drilling if we want to pass data to 1 or 2 levels or less levels down the hirarchy. But for futher, we use better approaches.

7. Solution to avoid prop drilling as our application grows - Use "React Context"

=> We can use some kind of global data which can be assessed in our app. Whether it's decendant component of any other component in our app.

=> React gives us a super power to do this called "React Context". It's a global place where we can store any data and it can be accessed
   by any component.

=> Lets implement this in our application. 
   Scenerio where the data will be used anywhere in our app  : 
   (1) Logged in user info
   example : Sometimes we need in header the logged in user, can be used in some footer, can be used in our card.

   (2) theme
   Example : if theme is dark, all the components should access the theme type to update themselves.

=> Creating and using React Context : 
   
  - We'll create context in a seperate file. Lets create it inside utils/
  - Lets call this as UserContext, which will keep the information about logged in user.
  - To create context, React gives us a utility called "createContext"

   import { createContext } from "react";
   
      const UserContext = createContext({
      loggedInUser: "Default User",
      });

      export default UserContext;

- We'll create the COntext using a utility function createContext() which will take an javascript object to store global data. Now we can access
  this userContext anywhere in my app.

- To Access this : React gives us a hook to access this Context called "useContext" in which we can pass the name of the context to access it's global data.

  Lets access this in our header component to show logged-in user once user logs in.

- in header.js 
   // import 
  import { useState, useContext } from "react";

  // using useContext hook
  const data = useContext(UserContext);

=> If we have this amazing React Context, cann't we pass all the data in it ? Why do we need props then ?

   - You'll use React Contexts only for the data you are using at multiple places. 
   - Using it to store all the data like all the props, doesn't make sense.

Note : We can use React Context in Class based components too but in a different manner. We cannot use any hooks in class based comopnents.

=> Modify the React Context  : Suppose after the login, the logged in username is returned and we want to modify the context data.

      in our App.js :
      ...................

      const AppLayout = () => {
      const [userName, setUserName] = useState();

      // sample authitencation code
      useEffect(() => {
         // some response from Authentical API returns the name of the user.
         const responseName = "Ayush";
         setUserName(responseName);
      }, []);

      return (
         <UserContext.Provider value={{ loggedInUser: userName }}>   // wrapping our entire code inside UserContext(Name of context we gave)
            <div className="app">                                    // with updated loggedInUser. The entire code inside UserContext.Provider
            <Header />                                               // will get updated with the new data of loggedInUser.
            <Outlet /> 
            </div>
         </UserContext.Provider>
      );
      };

   - We'll use a wrapper  <UserContext.Provider> </UserContext.Provider> and will provide the updated data as an object to "value" in UserContext.Provider.
     Now this, new data we provided for loggedInUser value will get reflected in all the code that is wrapped in inside our UserContext.Provider.
     Since, We have done this in our root of app in App.js, the loggedInUser will be "Ayush" everywhere in our app.
   
   - On the other hand, if we had wrapped UserContext.Provider only around the <Header/> component, then only the loggedInUser would be updated in 
     Header component but will remain original value ie. (Default user) everywhere else in our app. 
   
     eg :  
      return (
            <div className="app">    
            <UserContext.Provider value={{ loggedInUser: userName }}>                                 
              <Header />    
             </UserContext.Provider>                                         
            <Outlet /> 
            </div>
      );

   - One more example case : 
       
      return (
            <UserContext.Provider value={{ loggedInUser: "Ayush" }}>     
               <div className="app">    
               <UserContext.Provider value={{ loggedInUser: "Elon Musk" }}>                                 
               <Header />    
               </UserContext.Provider>                                         
               <Outlet /> 
               </div>
            <UserContext.Provider value={{ loggedInUser: userName }}>     
      );

      Here, our Header component will have UserContext with loggedInUser value as "Elon Musk" and rest of the code will have UserContext 
      with loggedInUser value as "Ayush".

    - We can have multiple UserContext.Provider in our app and wrap different code in it. Thus we can have different UserContext with 
     different data in out app :) based on what "value" we provide in UserContext.Provider.

=> (Important *** )Another way to modify our context : UserContext

   - If I want to change the "loggedInUser" value. I can do that if the change the state variable "userName" since in app.js we are setting 
     <UserContext.Provider value={{ loggedInUser: userName }}>....

   - Suppose we change the state variable userName, out componenent will rerender with a new LoggedInUser value in UserContext

   - How to update the userName state ? Using setUserName().
    
   - To make this setUserName avaiable for all the components so that any component can update app.js state variable setUserName, we'll pass
      setUserName function insider our UserContext.Provider values in app.js

      return (
         <UserContext.Provider
            value={{
            loggedInUser: userName,
            updateUserName: (name) => {      // passing setUserName function as a key and value a function, which will take a name and  setUserName(name); to update the state variable userName in App.js
               setUserName(name);         
            },
            }}
         >
            <div className="app">
            <Header />
            <Outlet />
            </div>
         </UserContext.Provider>
      );
    };
   
- To modify our userName state variable in App.js from Body.js : 

   // importing necessary 
   import { useState, useEffect, useContext } from "react";
   import UserContext from "../utils/UserContext";

  // updating the userName throughout the app by updating the userName local state variable to App.js.
   const { updateUserName } = useContext(UserContext);
   updateUserName("Rahul");

Summary : In our App.js we have tied together our State variable "userName" and Context variable "loggedInUser". So whenever this state variable
          "userName" changes in our app from anywhere, using setUserName() function. It'll change the contextVariable loggedInUser in our app and
          that will update all the UI places with our Context data loggedInUser is used. :).

8. Why user React Context when we use normal javascript variables too to store global data in some class ? 

=>  Our Context is soo powerful that, if we use lazy loaded modules, the new context data will get updated in that as well, once we update the
   context data from any component. Thats why we just not use local variables to store global data but use React Context.


9. Anything Better than Context for larger apps ? 

=> Yes Redux. It's a external library for creating a store to manage our states. But it's not a part of React like Context. Context is also very
   powerful even for mid size and larger apps. Use Redux for very larger apps since it's an external library, not a part of React which we install via 
   npm install.

=> We can use Context for any large application also. But in out industry, Redux has become very commmon since for developer it's very scalable since in Context,
   we have to create different context for different data. Example Card Context, Theme context, User context.
     
=> Akshay's Suggestion : Try to use Context as much as you can. Context is amazing and very efficient. When your app become very huge in future, then you can leverage the power
   of redux library.


  

   
   

